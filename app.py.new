import os
import sys
from datetime import datetime, timezone
import pandas as pd
from core.logger import setup_logger
from core.mt5_client import MT5Client
from strategies.indicators import atr, rsi
from safety_gate import Guard
from strategies.baseline import ma_crossover_signal
from services.telegram import TelegramClient
from services.chart_renderer import render_chart_with_overlays
from settings import settings
from utils.mt5_exec import place_market

logger = setup_logger()

def run_diag(mt5c: MT5Client):
    """Test MT5 connectivity and basic data fetching."""
    logger.info("Running diagnostic mode...")

    # Check MT5 connection
    snap = mt5c.account_snapshot()
    if not snap:
        logger.error("MT5 account snapshot failed!")
        return False

    # Test data fetch
    df = mt5c.get_rates(settings.SYMBOL, "M30", count=10)
    if df.empty:
        logger.error(f"Failed to fetch {settings.SYMBOL} rates!")
        return False
    logger.info(f"Successfully fetched {len(df)} bars for {settings.SYMBOL}")

    return True

def run_once():
    mt5c = MT5Client()
    if not mt5c.connect(
        login=settings.MT5_LOGIN or 0,
        password=settings.MT5_PASSWORD or "",
        server=settings.MT5_SERVER or "",
        path=settings.MT5_TERMINAL_PATH,
        attach_mode=bool(not settings.MT5_LOGIN),
    ):
        logger.error("MT5 холбогдож чадсангүй. Terminal нээж login хийсэн эсэхийг шалгана уу.")
        return False

    # Handle --diag flag
    if len(sys.argv) > 1 and sys.argv[1] == "--diag":
        success = run_diag(mt5c)
        mt5c.shutdown()
        return success

    # Make sure charts directory exists
    os.makedirs("charts", exist_ok=True)

    # Дансны мэдээлэл харуулах
    snap = mt5c.account_snapshot()
    if not snap:
        logger.error("Failed to get account snapshot!")
        mt5c.shutdown()
        return False

    account_balance = float(snap.get("balance", 0.0))

    # Initialize Telegram if configured
    tg = None
    if settings.TELEGRAM_BOT_TOKEN and settings.TELEGRAM_CHAT_ID:
        tg = TelegramClient(settings.TELEGRAM_BOT_TOKEN, settings.TELEGRAM_CHAT_ID)

    # Setup Guard with settings
    guard = Guard(
        symbol=settings.SYMBOL,
        timeframe_min=settings.TF_MIN,
        session=settings.SESSION,
        cooldown_mult=settings.COOLDOWN_MULT,
        min_atr=settings.MIN_ATR,
        risk_pct=settings.RISK_PCT,
        sl_mult=settings.SL_MULT,
        tp_mult=settings.TP_MULT,
        enable_news=True,
        news_window_min=60,
    )

    # Fetch and process data
    df = mt5c.get_rates(settings.SYMBOL, "M30", count=800)
    if df.empty:
        logger.warning(f"{settings.SYMBOL} хосын түүх хоосон байна")
        mt5c.shutdown()
        return False

    # Generate unique timestamp for chart
    ts = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S_%f")[:-3]
    out_png_rel = f"charts/{settings.SYMBOL}_M30_{ts}.png"

    # Render initial chart
    overlays = {"trendlines": [], "zones": [], "fibonacci": []}
    out_png = render_chart_with_overlays(df.tail(200), overlays, out_png_rel)
    logger.info(f"Chart saved: {out_png}")

    # Compute indicators
    sig = ma_crossover_signal(df)
    last_close = df["close"].iloc[-1]
    a = atr(df, period=20)  # Using standard 20-period ATR
    df["MA20"] = df["close"].rolling(window=20).mean()
    df["MA50"] = df["close"].rolling(window=50).mean()
    ma20 = float(df["MA20"].iloc[-1]) if not df["MA20"].isna().all() else float("nan")
    ma50 = float(df["MA50"].iloc[-1]) if not df["MA50"].isna().all() else float("nan")
    rsi14 = rsi(df["close"], period=14)

    # Base message for logging
    base_msg = f"[{settings.SYMBOL}] close={last_close:.2f} | atr={a:.5f} | signal={sig['signal']} | {sig['reason']}"
    logger.info(base_msg)

    # Get trading decision through safety gate
    decision = guard.filter_decision(
        raw_signal=sig["signal"],
        close=last_close,
        ma_fast=ma20,
        ma_slow=ma50,
        rsi=rsi14,
        atr=a,
        balance_usd=account_balance,
        now_utc=datetime.now(timezone.utc),
    )

    logger.info(
        f"[{settings.SYMBOL}] decision={decision.action} | lot={decision.lot} | "
        f"SL={decision.sl_points:.2f} | TP={decision.tp_points:.2f} | reason={decision.reason}"
    )

    if decision.action in ("BUY", "SELL"):
        # Place order using mt5_exec wrapper
        res = place_market(
            symbol=settings.SYMBOL,
            side=decision.action,
            lot=decision.lot,
            sl=decision.sl_points,
            tp=decision.tp_points
        )

        if res["ok"]:
            guard.mark_trade(decision.action)
            logger.info("Trade placed and cooldown marked by safety gate.")

            if tg:
                t = "DRY" if settings.DRY_RUN else f"TICKET {res['ticket']}"

                # Re-render chart with Entry/SL/TP annotations
                try:
                    overlays_anno = overlays.copy()
                    overlays_anno["annotate_levels"] = {
                        "entry": last_close,
                        "sl": decision.sl_points,
                        "tp": decision.tp_points
                    }
                    out_png_anno = render_chart_with_overlays(
                        df.tail(200), overlays_anno, out_png_rel,
                        f"{settings.SYMBOL} {decision.action}"
                    )

                    # Send notifications
                    tg.send(f"{base_msg}\n→ {t} | lot={decision.lot} | "
                           f"SL={decision.sl_points:.2f} | TP={decision.tp_points:.2f}")
                    tg.send_photo(out_png_anno, caption=f"{settings.SYMBOL} {decision.action} {t}")

                except Exception as e:
                    logger.exception("Failed to render/send annotated chart: %s", e)
        else:
            logger.error(f"Ордер биелүүлж чадсангүй (safety gate): {res}")
    else:
        logger.info("No trade after safety gate.")

    mt5c.shutdown()
    return True

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--diag":
        sys.exit(0 if run_once() else 1)
    else:
        run_once()
